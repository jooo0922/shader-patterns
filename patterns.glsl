#ifdef GL_ES
precision mediump float;
#endif

#define QUAR_PI .785 // 사각형을 45도 회전시켜 마름모로 그려줘야 하므로, 45도의 라디안값을 정의한 것.
#define ROOT2 1.414 // 마름모의 모서리가 맞닿을 수 있도록 마름모 사이즈를 지정하기 위해 ROOT2값을 정의함.

uniform vec2 u_resolution;
uniform float u_time;

// rect() 함수로 사각형을 그린 뒤, shader-rotate 예제에서 사용했던
// rotate2d() 함수로 사각형을 45도 정도 돌리면 마름모가 그려지겠지
mat2 rotate2d(float _angle) {
  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));
}

// 사각형을 그리는 함수를 먼저 정의함.
// 전달받는 매개변수는 1. 각 픽셀들 좌표값(coord), 2. 사각형 사이즈(size) -> 정확히는 정사각형 가로, 세로의 절반값
float rect(vec2 coord, vec2 size) {
  vec2 center = vec2(.0); // 사각형의 가운데 좌표값(캔버스의 정가운데 좌표값) -> main 함수에서 원점을 정가운데로 옮긴 상태임.

  // x, y 좌표값 각각을 기준으로 사각형 내에 들어오면 1, 아니면 0이 계산되어 
  // 각각 hor(가로), ver(세로) 변수에 들어가도록 하는 공식을 step() 내장함수로 만듦.
  // 근데 사실 이 방식이 shader-rectangle 에서 사용한 방식과 동일함
  // 왜냐면, (center.x - size.x, center.y - size.y) 가 결국 sw(좌하단)의 x, y 좌표값을 의미하기 때문
  // 같은 원리로 (center.x + size.x, center.y + size.y) 가 결국 ne(좌하단)의 x, y 좌표값을 의미하고,
  // sw, ne를 step() 내장함수로 계산한 결과값(pct)의 x, y 좌표값을 서로 곱해주는게 hor * ver 에 해당함.
  float hor = step(center.x - size.x, coord.x) - step(center.x + size.x, coord.x); // 가로(x좌표값) 기준
  float ver = step(center.y - size.y, coord.y) - step(center.y + size.y, coord.y);; // 세로(y좌표값) 기준

  // 사각형 내에 들어오는 영역은 1*1 = 1 이 리턴되고, 그 외의 영역은 0*0 = 0 이 리턴됨.
  return hor * ver;
}

void main() {
  vec2 coord = gl_FragCoord.xy / u_resolution;
  coord.x *= u_resolution.x / u_resolution.y;

  coord *= 3.; // 패턴화 1단계: 화면의 좌표계를 n배 확대할 것.
  coord = fract(coord); // 패턴화 2단계: fract() 내장함수로 각 픽셀들 좌표값을 소수점 값으로 Mapping 해서 패턴을 그려줄 것.

  // 자 이제 정사각형 패턴을 마름모 패턴으로 만들기 위해 회전을 시킬거임
  // 근데, 원점이 지금 어디에 있지? 좌하단에 위치하고 있지?
  // 또, 우리가 fract(coord)로 각 픽셀 좌표값을 Mapping 했기 때문에
  // coord의 값이 (0, 0)으로 Mapping 되는 지점이 아주 많아졌음.
  // 즉, 모든 사각형들의 좌하단이 (0, 0)으로 Mapping 되었다는 거지 fract()에 의해서...
  // 이 패턴 내의 각자의 사각형들은, 원점을 기준으로 회전하는 건 맞는데, 이 때
  // '자기가 속해있는 원점을 기준으로 회전한다' 라는 걸 잊으면 안됨.
  // 즉, 첫 번째 사각형의 좌하단만 원점인 게 아니라, Mapping된 모든 각각의 원점을 기준으로
  // 각각의 사각형들이 rotate2d() 함수에 의해 회전한다는 것임!
  // 왜냐하면, fract() 를 사용한 순간, 각각의 사각형에 대해 각각의 원점이 존재하게 되기 때문임!

  // 원점을 좌하단에서 캔버스 정가운데로 옮기기 위해 각 픽셀들 좌표값을 Mapping함.
  // 정사각형이 마름모 형태로 회전하려면 회전의 중심축인 원점을 설정할 때, 캔버스의 가운데로 설정해줘야 함.
  // 이렇게 하면 각 사각형들은 각자의 원점이 각자의 정가운데로 이동한 상태가 됨.
  coord -= 0.5;

  // 사각형 각자의 원점들이 각자의 정가운데로 이동한 상태에서 45도 회전시키는 2*2 회전행렬을 리턴받아 곱해줌.
  // 각 사각형들은 각자가 속한 원점을 기준으로 회전하게 됨.
  coord *= rotate2d(QUAR_PI);
  // coord *= rotate2d(u_time); // 이런 식으로 제자리에서 뱅글뱅글 도는 애니메이션 패턴도 만들 수 있음.

  /*
    그런데, 우리는 마름모의 끝부분이 맞닿도록 하고 싶음.
    즉, 마름모의 각 꼭지점을 연결한 대각선 길이가 1.0이 되도록 맞추고 싶음.

    이 때, 마름모의 대각선 길이의 절반이 0.5가 되어야 할 것이고,
    rect()의 두 번째 인자로 넣어주는, 사각형의 가로(또는 세로)의 절반 사이즈값은
    언제나 이 마름모 대각선의 절반 길이 0.5에 제곱근 2 를 나눠준 값으로 계산하게 되어있음. 
    -> 피타고라스 정리
    
    따라서, 위에 코드에서 define 해놓은 제곱근 2 값을 0.5로 나눠준 값을 
    rect()의 두 번째 인자로 넣어줘야 하겠지

    그런데 주의할 점은, 컴퓨터는 항상 나눗셈보다 곱셈을 좋아함. 니늣셈은 약간 복잡한 연산인 것.
    가급적이면 컴퓨터가 나눗셈을 하는 일이 없도록 하는 게 좋기 때문에,
    나눗셈을 해야 할 일이 있다면 그냥 미리 계산을 해놓은 뒤 결과값을 define 해놓고 사용하는 게 가장 좋음.
  
    .5 / ROOT2 값은 대략 0.353... 이기 때문에
    그냥 vec2(0.353)으로 size값을 넣어주는 게 좋음. 
    -> 컴퓨터가 좀 더 빨리 돌아갈 수 있음.
    지금은 굉장히 사소한 계산처럼 보이지만 이런 습관을 연습할 때부터 들여놓아야 함...
  */
  vec3 col = vec3(rect(coord, vec2(.353)));

  gl_FragColor = vec4(col, 1.);
}

/*
  fract() / mod() 내장함수로 패턴 그리기


  fract() 는 인자로 넣어주는 float값의 소수 부분(fractional part)만 리턴해 줌.
  
  mod() 는 fract() 와 정확히 동일한 기능을 하는 내장함수는 아니지만,
  mod(나눠지는 값, 1.0(나눠주는 값)) 이렇게 사용하면 1로 나누면 나머지는 항상 0 ~ 1 사이의 값이 나오므로,
  사실상 fract() 내장함수와 동일한 기능을 한다고 보면 됨.

  근데, 어쨋든 fract(coord) 를 호출하기 전에는 원이 하나만 그려졌는데
  fract(coord)를 호출하고 나니까 원이 여러 개 그려지는 이유는 뭘까?

  예를 들어, 지금 우리가 화면의 좌표계를 3배로 늘렸지?
  그러면 맨 첫번째 원은 vec2(0.5, 0.5) 지점에 존재하니까, 
  아래의 step() 내장함수에 의해서 반지름 0.3의 원이 그려져야 하는 거잖아.

  근데, 두번째 원은 vec2(1.5, 0.5) 지점에 존재하기 때문에
  원래대로라면 원이 그려지면 안되는 게 맞음. 그냥 흰색으로 다 칠해져야 맞지.

  그런데, fract(coord)를 함으로 인해서,
  fract(vec2(1.5, 0.5)) 이렇게 해버리면 그 결과값이 결국 fract(vec2(0.5, 0.5))로 리턴되어버림.
  소수점 부분만 리턴해주니까!

  따라서, step() 함수 안으로 들어가는 coord값이 첫 번째 원에서와 동일하게
  vec2(0.5, 0.5) 로 들어가기 때문에, 이 영역에도 검정색 픽셀들이 칠해지게 되는 것임!


  따라서, 어떤 도형을 만든 다음, 
  그것을 패턴으로 만들고 싶다면, 두 가지 단계를 거쳐야 함.

  1. 화면의 좌표계를 n배로 확대함
  2. fract(coord) 또는 mod(coord, 1.0) 으로 
  각 픽셀들의 좌표값을 0 ~ 1 사이의 소수값으로 다시 리턴받은 뒤에 패턴을 그려주는 계산에 사용하도록 함. 
*/